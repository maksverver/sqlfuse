Next:
  - sqlfs.c: set passwords & parameters (see TODO in sqlfs_create)
  - Test if other filesystems support creating files/subdirectories in unlinked
    directories (using unlink()/createnodat()?). How should I handle that case?
  - test unlinking of open files, and reading/writing from them
  - Delete unlinked files/directories at startup. (Note: should also delete
    file/directory contents!)
  - sqlfs.c: Maybe: separate functions to create/open existing database?
  - CLI: does it make sense to separate database creation from mounting?
    For example:
      sqlfuse -c new.db    # creates file
      sqlfuse new.db mnt   # mounts it
    Exit with an error if a mountpoint is specified in the first case.
  - CLI: if creating the database fails, should we delete the partially-created
    database file (which will be empty)?
  - Figure out what happens if an open directory is deleted?
  - Create a logging mode where we log warnings/errors but don't print function
    call traces? (This would be useful for normal foreground use.) Maybe just
    write to stderr directly for important errors/warnings?
  - Revisit transaction functions (sql_begin_transaction() etc.): they currently
    emulate nested transactions with savepoints. It might be less confusing if they
    were named after the SQL statements they actually execute. Maybe the functions
    that use transactions should be restructured as follows:

      sql_savepoint(sqlfs);
      int err = ...;
      if (err != 0) {
        goto failure;
      }
    success:
      CHECK(err == 0);
      goto finish;
    failure:
      CHECK(err != 0);
      sql_rollback_to_savepoint(sqlfs);
    finish:
      sql_release_savepoint(sqlfs);
      return err;

Things to test:
  - some manual smoke-testing: verify that files are actually purged during
    normal operation (auto-create a bunch of files and delete them?)
  - open read-only database file (read operations should still succeed,
    write operations should fail gracefully, without crashing)
  - sqlfs tests with encryption (no setup/teardown)
  - sqlfuse: parallel reading from two directories / one directory opened twice
    (this only makes sense to test with very large directories otherwise the
     entire directory is probably read into one buffer?)
  - Add unit tests on the sqlfs level:
     - unaligned read() (currently entirely untested!)
     - opendir()/readdir()/closedir() with various edge cases
  - test on 32-bit ARM -- check that binary format is compatible!
  - mtrace() seems buggy in multithreaded environment. Get rid of leak tests?

TBD:
  - what should the uid/gid/mode of the root directory be?
  - should we apply the umask manually, or does the kernel handle this?
    (test it with mkdir once that works!)

Decisions to document somewhere:
  - ctime and atime are not stored. (They're not very useful.)
  - For performance reasons, the inode PRIMARY KEY in the metadata table is not
    declared as AUTOINCREMENT. Because we always set the `generation` field to a
    fixed value, that means the filesystem cannot be exported over NFS! An
    alternative solution would be to store the creation timestamp in the
    metadata table, and use that as the generation number.
  - Directory reading: we use "next_name" instead of "last_name" as the
    continuation token (and "SELECT ... WHERE name >= next_name", instead of
    "WHERE name > last_name") to avoid having to copy strings in
    sqlfuse_readdir() to remember the last entry name.
  - All write operations commit to the database, so there is no need to flush()
    or sync() anything.
  - Sparse files are currently not supported. Maybe later!
  - Permission bits sticky/setuid/setgid (mask 07000) are currently not
    supported. Maybe later! (Careful: we should clear setuid/setgid bits when
    the owner/group of a file is changed.)
  - No tests for setuid()/setgid() because that (probaby?) requires root
    privileges.
  - No implementation for open/release, because we implement stateless file I/O.
  - Permission checking is deferred to libfuse. This has not been tested.
    It's probably not safe to share the filesystem with others (i.e. using the
    -o allow_others mount option).

General TODO:
  - create a README with some information and usage notes.
  - fully document the schema definition (wait until the implementation is
    further along; no point documenting it when it's likely to change)
  - fsck tool that checks internal consistency?
    (once implemented, add it to teardown() in sqlfuse_test to verify that each
    test case leaves the filesystem in a consistent state, without dangling
    pointers and so on).
  - dump tool to dump contents of database?
  - another tool to rekey the database?

Things I learned about fuse:
  - direct_io mode is not available in low-level mode. Without it (by default),
    file access goes through the kernel's page cache, which makes testing more
    difficult, but it has the benefit that reads are aligned to page boundaries.

    (The underlying sqlfs library would support direct I/O and unaligned read()/
    write() calls.)

  - The keep_cache flag allows the kernel to cache file data. The kernel will
    invalidate the cache automatically. This mode is applicable to filesystems
    where the underlying data cannot change except through the kernel API, which
    is true for us (but wouldn't be true for e.g. a network filesystem that can
    be modified by multiple users at once).

    (How does this relate to the kernel_cache mount option?)

  - TODO: go over other mount options? (For example, we do support returning
    inos in readdir().)

  - Lookup accounting: I/O may be performed on files and directories after they
    are deleted. To track which entries are still active, the kernel module
    maintains a lookup count per inode number.

      - Each time an inode number is sent to the kernel with fuse_reply_entry()
        or fuse_reply_create(), its lookup count increases by 1. (We don't
        implement create(), so we can ignore the second function.)
      - Each time an inode number is passed to forget(), its lookup count
        decreases by 1.
      - When an inode number's lookup count reaches zero, and its link count is
        zero, then it may be permanently deleted. (We implement this in
        sqlfs_purge(), which removes a file but only if its link count is zero.)
      - It's not guaranteed that all inode numbers are forgotten before
        destroy() is called (when the filesystem is unmounted), so on destroy,
        we should purge all entries with positive lookup count.
