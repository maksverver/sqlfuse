Next:
  - think about a cool name & rebrand everything?
  - only trace in debug mode
  - implement rekey command:
      should prompt once for old password, twice for new password.
      implement using sqlite3_rekey.
  - implement vacuum command:
      should purge first, then vacuum.
  - implement fsck command (verify that it works on read only files)
  - Revisit transaction functions (sql_begin_transaction() etc.): they currently
    emulate nested transactions with savepoints. It might be less confusing if they
    were named after the SQL statements they actually execute. Maybe the functions
    that use transactions should be restructured as follows:

      sql_savepoint(sqlfs);
      int err = ...;
      if (err != 0) {
        goto failure;
      }
    success:
      CHECK(err == 0);
      goto finish;
    failure:
      CHECK(err != 0);
      sql_rollback_to_savepoint(sqlfs);
    finish:
      sql_release_savepoint(sqlfs);
      return err;

  - Consider calling sqlfs_purge_all() in destroy rather than purging each open
    inode individually? (It would have the benefit that sqlfs_purge_all() is
    more efficient because it can use an index to find unlinked entries.)

Things to test:
  - some manual smoke-testing: verify that files are actually purged during
    normal operation (auto-create a bunch of files and delete them?)
  - open read-only database file (read operations should still succeed,
    write operations should fail gracefully, without crashing)
  - sqlfs tests with encryption (no setup/teardown)
  - sqlfuse: parallel reading from two directories / one directory opened twice
    (this only makes sense to test with very large directories otherwise the
     entire directory is probably read into one buffer?)
  - Add unit tests on the sqlfs level:
     - unaligned read() (currently entirely untested!)
     - opendir()/readdir()/closedir() with various edge cases
  - test on 32-bit ARM -- check that binary format is compatible!
  - mtrace() seems buggy in multithreaded environment. Get rid of leak tests?

TBD:
  - what should the uid/gid/mode of the root directory be?
  - should we apply the umask manually, or does the kernel handle this?
    (test it with mkdir once that works!)

Decisions to document somewhere:
  - No multithreading support. It complicates everything, is not immediately
    necessary, and would not work well with SQLite (since SQLite serializes
    transactions by default).
  - ctime and atime are not stored. (They're not very useful.)
  - Each file has an associated block size (which can vary between files, though
    it's 4 KiB by default). File data is stored as a series of blocks, indexed
    from 0 to N. Blocks 0 through N - 1 have size `blocksize`; the N-th block
    is shorter if the file size is not a multiple of the blocksize. Blocks are
    never empty.
  - Sparse files are currently not supported. Maybe later!
  - For performance reasons, the inode PRIMARY KEY in the metadata table is not
    declared as AUTOINCREMENT. Because we always set the `generation` field to a
    fixed value, that means the filesystem cannot be exported over NFS! An
    alternative solution would be to store the creation timestamp in the
    metadata table, and use that as the generation number.
  - Directory reading: we use "next_name" instead of "last_name" as the
    continuation token (and "SELECT ... WHERE name >= next_name", instead of
    "WHERE name > last_name") to avoid having to copy strings in
    sqlfuse_readdir() to remember the last entry name.
  - All write operations commit to the database, so there is no need to flush()
    or sync() anything.
  - Permission bits sticky/setuid/setgid (mask 07000) are currently not
    supported. Maybe later! (Careful: we should clear setuid/setgid bits when
    the owner/group of a file is changed.)
  - No tests for setuid()/setgid() because that (probaby?) requires root
    privileges.
  - No implementation for open/release, because we implement stateless file I/O.
  - Permission checking is deferred to libfuse. This has not been tested.
    It's probably not safe to share the filesystem with others (i.e. using the
    -o allow_others mount option).

Future ideas:
  - Transparent compression of file data? Or maybe this can be implemented on a
    lower level (compressing the database file itself)?

General TODO:
  - create a README with some information and usage notes.
  - fully document the schema definition (wait until the implementation is
    further along; no point documenting it when it's likely to change)
  - fsck tool that checks internal consistency?
    (once implemented, add it to teardown() in sqlfuse_test to verify that each
    test case leaves the filesystem in a consistent state, without dangling
    pointers and so on).
  - dump tool to dump contents of database?
  - another tool to rekey the database?

Things I learned about fuse:
  - direct_io mode is not available in low-level mode. Without it (by default),
    file access goes through the kernel's page cache, which makes testing more
    difficult, but it has the benefit that reads are aligned to page boundaries.

    (The underlying sqlfs library would support direct I/O and unaligned read()/
    write() calls.)

  - The keep_cache flag allows the kernel to cache file data. The kernel will
    invalidate the cache automatically. This mode is applicable to filesystems
    where the underlying data cannot change except through the kernel API, which
    is true for us (but wouldn't be true for e.g. a network filesystem that can
    be modified by multiple users at once).

    (How does this relate to the kernel_cache mount option?)

  - TODO: go over other mount options? (For example, we do support returning
    inos in readdir().)

  - Lookup accounting: I/O may be performed on files and directories after they
    are deleted. To track which entries are still active, the kernel module
    maintains a lookup count per inode number.

      - The root inode (number 1) starts with lookup count 1.
      - Each time an inode number is sent to the kernel with fuse_reply_entry()
        or fuse_reply_create(), its lookup count increases by 1. (We don't
        implement create(), so we can ignore the second function.)
      - Each time an inode number is passed to forget(), its lookup count
        decreases by 1.
      - When an inode number's lookup count reaches zero, and its link count is
        zero, then it may be permanently deleted. (We implement this in
        sqlfs_purge(), which removes a file but only if its link count is zero.)
      - It's not guaranteed that all inode numbers are forgotten before
        destroy() is called (when the filesystem is unmounted), so on destroy,
        we should purge all entries with positive lookup count.
