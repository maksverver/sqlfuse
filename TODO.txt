Next:
  - Fix hardlink counting of directories: we should not count the self-link
    in the nlink column of the metadata table. This way, an empty directory
    has nlink == 0, which allows us to easily garbage collect it (similar to
    unlinked files).
  - Test if other filesystems support creating files/subdirectories in unlinked
    directories (using unlink()/createnodat()?). How should I handle that case?
  - open()/close() of files
  - read()/write() of files
  - truncate() of files.
  - sqlfs.c: set passwords & parameters (see TODO in sqlfs_create)
  - test unlinking of open files, and reading/writing from them
  - Lookup accounting!!!
  - Delete unlinked files/directories at startup. (Note: should also delete
    file/directory contents!)
  - sqlfs.c: Maybe: separate functions to create/open existing database?
  - CLI: does it make sense to separate database creation from mounting?
    For example:
      sqlfuse -c new.db    # creates file
      sqlfuse new.db mnt   # mounts it
    Exit with an error if a mountpoint is specified in the first case.
  - CLI: if creating the database fails, should we delete the partially-created
    database file (which will be empty)?
  - Figure out which functions increase the 'lookup count' for an inode;
    document this somewhere.
  - Figure out what happens if an open directory is deleted?

Things to test:
  - open read-only database file (read operations should still succeed,
    write operations should fail gracefully, without crashing)
  - sqlfs tests with encryption (no setup/teardown)
  - sqlfuse: parallel reading from two directories / one directory opened twice
    (this only makes sense to test with very large directories otherwise the
     entire directory is probably read into one buffer?)
  - Add unit tests on the sqlfs level:
      - opendir()/readdir()/closedir()


TBD:
  - what should the uid/gid/mode of the root directory be?
  - should we apply the umask manually, or does the kernel handle this?
    (test it with mkdir once that works!)

Decisions to document somewhere:
  - ctime and atime are not stored. (They're not very useful.)
  - For performance reasons, the inode PRIMARY KEY in the metadata table is not
    declared as AUTOINCREMENT. Because we always set the `generation` field to a
    fixed value, that means the filesystem cannot be exported over NFS! An
    alternative solution would be to store the creation timestamp in the
    metadata table, and use that as the generation number.
  - Directory reading: we use "next_name" instead of "last_name" as the
    continuation token (and "SELECT ... WHERE name >= next_name", instead of
    "WHERE name > last_name") to avoid having to copy strings in
    sqlfuse_readdir() to remember the last entry name.

General TODO:
  - create a README with some information and usage notes.
  - fully document the schema definition (wait until the implementation is
    further along; no point documenting it when it's likely to change)
  - fsck tool that checks internal consistency?
    (once implemented, add it to teardown() in sqlfuse_test to verify that each
    test case leaves the filesystem in a consistent state, without dangling
    pointers and so on).
  - dump tool to dump contents of database?
  - another tool to rekey the database?
