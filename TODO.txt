Next:
  - sqlfuse_rename()
  - verify rename() is used when unlinking an open file?
  - Lookup accounting!!! + sqlfuse_forget()
  - sqlfs.c: set passwords & parameters (see TODO in sqlfs_create)
  - Test if other filesystems support creating files/subdirectories in unlinked
    directories (using unlink()/createnodat()?). How should I handle that case?
  - test unlinking of open files, and reading/writing from them
  - Delete unlinked files/directories at startup. (Note: should also delete
    file/directory contents!)
  - sqlfs.c: Maybe: separate functions to create/open existing database?
  - CLI: does it make sense to separate database creation from mounting?
    For example:
      sqlfuse -c new.db    # creates file
      sqlfuse new.db mnt   # mounts it
    Exit with an error if a mountpoint is specified in the first case.
  - CLI: if creating the database fails, should we delete the partially-created
    database file (which will be empty)?
  - Figure out which functions increase the 'lookup count' for an inode;
    document this somewhere.
  - Figure out what happens if an open directory is deleted?
  - Revisit transaction functions (sql_begin_transaction() etc.): they currently
    emulate nested transactions with savepoints. It might be less confusing if they
    were named after the SQL statements they actually execute. Maybe the functions
    that use transactions should be restructured as follows:

      sql_savepoint(sqlfs);
      int err = ...;
      if (err != 0) {
        goto failure;
      }
    success:
      CHECK(err == 0);
      goto finish;
    failure:
      CHECK(err != 0);
      sql_rollback_to_savepoint(sqlfs);
    finish:
      sql_release_savepoint(sqlfs);
      return err;

Things to test:
  - open read-only database file (read operations should still succeed,
    write operations should fail gracefully, without crashing)
  - sqlfs tests with encryption (no setup/teardown)
  - sqlfuse: parallel reading from two directories / one directory opened twice
    (this only makes sense to test with very large directories otherwise the
     entire directory is probably read into one buffer?)
  - Add unit tests on the sqlfs level:
     - unaligned read() (currently entirely untested!)
     - opendir()/readdir()/closedir() with various edge cases
  - test on 32-bit ARM -- check that binary format is compatible!
  - mtrace() seems buggy in multithreaded environment. Get rid of leak tests?

TBD:
  - what should the uid/gid/mode of the root directory be?
  - should we apply the umask manually, or does the kernel handle this?
    (test it with mkdir once that works!)

Decisions to document somewhere:
  - ctime and atime are not stored. (They're not very useful.)
  - For performance reasons, the inode PRIMARY KEY in the metadata table is not
    declared as AUTOINCREMENT. Because we always set the `generation` field to a
    fixed value, that means the filesystem cannot be exported over NFS! An
    alternative solution would be to store the creation timestamp in the
    metadata table, and use that as the generation number.
  - Directory reading: we use "next_name" instead of "last_name" as the
    continuation token (and "SELECT ... WHERE name >= next_name", instead of
    "WHERE name > last_name") to avoid having to copy strings in
    sqlfuse_readdir() to remember the last entry name.
  - All write operations commit to the database, so there is no need to flush()
    or sync() anything.
  - Sparse files are currently not supported. Maybe later!
  - Permission bits sticky/setuid/setgid (mask 07000) are currently not
    supported. Maybe later! (Careful: we should clear setuid/setgid bits when
    the owner/group of a file is changed.)
  - No tests for setuid()/setgid() because that (probaby?) requires root
    privileges.
  - No implementation for open/release, because we implement stateless file I/O.
  - Permission checking is deferred to libfuse. This has not been tested.
    It's probably not safe to share the filesystem with others (i.e. using the
    -o allow_others mount option).

General TODO:
  - create a README with some information and usage notes.
  - fully document the schema definition (wait until the implementation is
    further along; no point documenting it when it's likely to change)
  - fsck tool that checks internal consistency?
    (once implemented, add it to teardown() in sqlfuse_test to verify that each
    test case leaves the filesystem in a consistent state, without dangling
    pointers and so on).
  - dump tool to dump contents of database?
  - another tool to rekey the database?

Things I learned about fuse:
  - direct_io mode is not available in low-level mode. Without it (by default),
    file access goes through the kernel's page cache, which makes testing more
    difficult, but it has the benefit that reads are aligned to page boundaries.

    (The underlying sqlfs library would support direct I/O and unaligned read()/
    write() calls.)

  - The keep_cache flag allows the kernel to cache file data. The kernel will
    invalidate the cache automatically. This mode is applicable to filesystems
    where the underlying data cannot change except through the kernel API, which
    is true for us (but wouldn't be true for e.g. a network filesystem that can
    be modified by multiple users at once).

    (How does this relate to the kernel_cache mount option?)

  - TODO: go over other mount options? (For example, we do support returning
    inos in readdir().)
